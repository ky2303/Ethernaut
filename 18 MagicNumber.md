# 18. MagicNumber
Difficulty 6/10

To solve this level, you only need to provide the Ethernaut with a `Solver`, a contract that responds to `whatIsTheMeaningOfLife()` with the right number.

Easy right? Well... there's a catch.

The solver's code needs to be really tiny. Really reaaaaaallly tiny. Like freakin' really really itty-bitty tiny: 10 opcodes at most.

Hint: Perhaps its time to leave the comfort of the Solidity compiler momentarily, and build this one by hand O_o. That's right: Raw EVM bytecode.

Good luck!

https://github.com/Sekin/ethereum-bytecode-deployment
https://medium.com/@blockchain101/solidity-bytecode-and-opcode-basics-672e9b1a88c2

```
contract A {
    function whatIsTheMeaningOfLife() public returns (uint8){
        return 42;
    }
}
```

https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2

led to this:
https://blog.openzeppelin.com/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737/

notes:
- opcodes always flow top to bottom
- yul consumes stack elements left to right
- inputs are an instruction (PUSH1 80 = 2 instructions)
- calldata: encoded chunk of hex containing function info and args/data, generated by hashing function signature and truncating to first 4 bytes followed by packed arg data

|opcode|what it does|
|---|---|
|`JUMP`|take top value on stack and move to that location, location must be a `JUMPDEST`|
|`JUMPDEST`|mark location as valid jump target|
|`JUMPI`|"jump if" ; same as jump but only jumps if second pos of stack != 0|
|`STOP`| completely halt execution of contract|
|`RETURN`|halt execution but return portion of EVM memory|
|`PUSH1`|push one byte to top of stack|
|`MSTORE`|grab top 2 value from stack and stores 2nd (2nd from top) value at 1st (top) location in memory|
|`CALLVALUE`|pushes creation tx wei to stack|
|`DUP1`|duplicate first value on stack (`DUP2`, `DUP3`, `DUP4`, etc duplicate 2nd, 3rd, 4th values, etc)|
|`ISZERO`|pushes 1 (true) to stack if top value is 0|
|`PUSH2`|pushes two bytes to stack|
|`REVERT`|halt execution|
|`CODECOPY`|copy code to target memory position; 3 args |target memory position to copy code to (top of stack), instruction number to copy from (2nd) , number of bytes to copy (3rd)|
|`ADD`|take top 2 values from stack and add then put result on top of stack|
|`SWAP1`|swaps top 2 values on stack|
|`SSTORE`|put value in storage; 2 args |where to store (top of stack), what to store (2nd on stack)|
|`CALLER`|pushes contract caller to stack|
|`SHA3`|hash memory location given by top of stack (2nd arg is length in bytes) and push result to stack|
|`CALLDATASIZE`|returns size of input data into current env|
|`LT`|less than|
|`CALLDATALOAD`|takes 1 param, reads 32 bytes from calldata at param position|
|`DIV`|divide 1st number on stack by 2nd number and push result to stack|
|`AND`|and operator on top 2 numbers on stack and push result to stack|
|`EQ`|check if top 2 values on stack are equal, push result to stack|
|`SLOAD`|read from storage at key given by top of stack, push result to stack|
|`MLOAD`|read from memory at location given by top of stack, push result to stack|
|`LOG0-4`|log events in blockchain|
|`CODECOPY`|copy executing contract's bytecode|

All EVM opcodes here: https://www.ethervm.io/  

### Using the Coinmonks guide:  
Even after reading through all of OpenZeppelin's articles, struggled to get a small contract deployed. Coinmonk's guide was helpful for getting the initialization correct, most importantly the `codecopy` opcode.

Runtime:

|Opcodes|Bytecodes|
|---|---|
|PUSH1 2a|60 2a (42 in hex)|
|PUSH1 80|60 80 (memoryslot)|
|MSTORE|52|
|PUSH1 20|60 20 (32 bytes)|
|PUSH1 80|60 80 (memory slot)|
|RETURN|F3|

Resulting code: `602a60805260206080f3`  

Initialization:  

|Opcodes|Bytecodes|
|---|---|
|PUSH1 0a|60 0a (destOffset: 10 bytes)|
|PUSH1 0c|60 0c (offset: 12 bytes, size of initialiation codes and position of runtime opcodes)|
|PUSH1 00|60 00 (length: 10, size of runtime bytecodes)|
|CODECOPY|39 (args are on stack)|
|PUSH1 0a|60 0a (return length)|
|PUSH1 00|60 00 (return offset)|
|RETURN|f3 (return to EVM)|

Resulting code: `0x600a600c600039600a6000f3602a60805260206080f3`

Used the console to solve the instance:  
create a new contract using:
`sendTranssaction({from:player, data:"0x600a600c600039600a6000f3604260805260206080f3"})`
get the contract address from etherscan
`await contract.setSolver("[contract address]")`

**END** looked up solution

Congratulations! If you solved this level, consider yourself a Master of the Universe.

Go ahead and pierce a random object in the room with your Magnum look. Now, try to move it from afar; Your telekinesis habilities might have just started working.